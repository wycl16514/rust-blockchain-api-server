If we goto any blockchain explorer application, you can search any transaction or block info by inputting the given transaction or bloch hash, then the frontend will send the request to backend server, the later will use blockchain running
on its onw machine to query the given info then return the result to fontend page to show.

From this section, we will see how to build up such api server to enable users from frontend to query info about blockchain. And luckily we have setupt http server in previous section, now our job is how to combine our blockchain layer to 
serve any requests coming from frontend to the server. Let's pull up the server first, in cargo.toml we add the http server crate as following;

```rs
[dependencies]
actix-web = "4.1"
```

Then we create a new folder name apiserver, and create a new file inside it with name mod.rs, add the following code in the file:

```rs
use actix_web::{web, App, HttpResponse, HttpServer};
use serde::Deserialize;

pub struct ApiServer {
    port : u64,
}

impl ApiServer {
    pub fn new(port :u64) -> Self {
        return ApiServer{
            port,
        }
    }

    async fn get_index() -> HttpResponse {
        HttpResponse::Ok().body("Hello, world!")
    }


    pub async fn run(&self) {
        let server = HttpServer::new(||{
            App::new().route("/", web::get().to(Self::get_index))
        });
        println!("server run on port: {}", self.port);
        server.bind(("0.0.0.0", self.port))
        .unwrap().run()
        .await.expect("error running the server");
    }
}
```

Then let's goto run the server at main.rs as following:

```rs

pub mod apiserver;
use crate::apiserver::ApiServer;

#[actix_web::main]
async fn main() {
    let server = ApiServer::new(5000);
    server.run();
}
```

Run above code, make sure the server can pull up and test the server by using http://localhost:5000/ in browser, if everything gose ok, you should get result as following:



![截屏2024-11-17 16 07 55](https://github.com/user-attachments/assets/a644b86d-6ef7-42ff-b308-0c09602ed45e)

Now let's try to return some blockchain info from the given index request. First we need to add some logging crate for actix_web server in cargo.toml:

```rs
[dependencies]
env_logger = "0.10"
log = "0.4"
```

Then we bring Blockchain crate into apiserver crate as following:

```rs
use crate::blockchain::BlockChain;
use crate::wallet::Wallet;
use std::sync::Arc;
use std::collections::HashMap;
use log::{error, warn, info, debug, trace};

#[derive(Clone, Debug)]
pub struct ApiServer {
    port : u64,
    cache: HashMap<String, BlockChain>,
}
```

Since we add the clone derive for ApiServer, we need to make sure BlockChain also can be cloned, therefore we need to add that derive for it as following in mod.rs of blockchain:

```rs
#[derive(Debug,Serialize,Clone)]
pub struct Block {
    nonce: i32,
    previous_hash: Vec<u8>,
    time_stamp: u128,
    transactions: Vec<Vec<u8>>,
}

...

#[derive(Debug, Clone)]
pub struct BlockChain {
    /*
    any transaction before going to the chain will wait on the transaction pool
    until they are minted, we will goto the detail at later
    */
    transaction_pool: Vec<Vec<u8>>,
    chain: Vec<Block>,
    //the address for the miner
    blockchain_address: String,
}
```

Back to apiserver, we the web server is running up, it will spawn several threads to handle incoming requests, normally actix_web will spawn 4 worker threads to serve incoming requests, 
if there are less than 4 requests come to it simutaniously,then each request will be served at the same time, but if there are more than 4 requests, the fifth need to wait until there is one can be served and 
therefore there is one worker thread free up to serve the fifth request.

The mutiple threads case bring a problem that is shared data. We need to shared the Blockchain object to multiple thread and make sure the given shared data object is not wrongly free up when there are still woker thread using it. And we need
to think about the race condition problem, there is only one thread can change the shared data at any time, and when the shared data is being changed, we need to make sure other threads can't read into it. Therefore we need some counting or
lock mechanism to prevent race condition problem.

For enabling threads sharing the same data object, we can use std::sync::Arc, it is an automic resources counter, it will wrap around the give resource and maintain a counter on it, if there is still threads holding the shared data, its 
counter will not be 0 and the shared data will not drop from memory.

The 
